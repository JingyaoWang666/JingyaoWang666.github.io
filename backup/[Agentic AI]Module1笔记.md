### 一、介绍
课程目标：掌握如何用智能体构建应用，是 AI 领域中最重要且最有价值的技能之一。
那些真正懂得如何构建智能体 AI 的人与效率较低的人之间的最大区别在于：能否推动有纪律的开发流程，特别是专注于**评估与错误分析**（evals and error analysis）的流程。

本课程将详细解释这一点，并教你如何精通构建这些**基于智能体的工作流**。
_有趣的是，我以前也主要关注到LLM版本的迭代，但实际上workflow，或者说其工作方式、工作流程对LLM输出的优化作用不可忽视，甚至比版本迭代的作用还要大。_

### 二、What is agentic AI?

<img width="900" height="500" alt="Image" src="https://github.com/user-attachments/assets/e9b38913-256b-48b8-9cb2-c3524a862d5b" />

An agentic Al workflow：**指基于大语言模型（LLM）的应用程序执行多个步骤以完成任务的过程。**这就是这门课的核心讨论对象。
智能体AI工作流是一种基于大型语言模型的应用流程，它通过执行多个步骤来完成一个复杂任务。它与“零样本”工作流的核心区别在于其迭代性和分解性。

> 工作流示例——撰写文章
> 写大纲： 让LLM先写出文章的大纲。
> 决定是否需要研究： 让另一个LLM判断是否需要进行网络搜索。
> 执行研究： 如果需要，调用网络搜索API，获取相关网页信息。
> 写初稿： 将下载的网页内容输入给LLM，让它撰写第一稿。
> 反思与修订： 让LLM反思初稿，决定哪些部分需要修改或补充更多研究。
> 人工审核（可选）： 在关键环节，可以让LLM请求人工审核，例如确认某些关键事实。
> 最终修订： 根据反馈或自我反思，对草稿进行最终修改。
> 虽然这种迭代式的工作流可能花费更长时间，但它能产出质量更高、更全面的工作成果


### 三、自主程度degrees of autonomy
Idea：使用“Agentic”作为形容词，而非名词。这允许我们说一个系统“具有某种程度的智能体特性”，而不是纠结于它是否“足够自主”才能被称为“智能体”。与其去争论哪些工作算是智能体，哪些不算“真正的智能体“，不如让我们承认不同系统在主动性方面的不同程度。

Less autonomous（低自主性）
所有步骤都是预先设定好的，所有工具调用都是硬编码的（Hard-coded），由人类工程师在代码中固定；其中主要自主性体现在语言模型生成的文本上。

案例
> 你告诉 LLM：“写一篇关于黑洞的论文”
> LLM → 写出搜索关键词
> 去网页搜
> 抓取网页内容
> LLM 把这些内容整合成文章
> 这就像你指挥一个“听话但不会动脑”的助手：你得一步步告诉它做什么、什么时候查资料、怎么整理。AI 只负责“写”，其他事都得你来操心。

More autonomous（高自主性）
代理能自主做出大量决策；能够动态地决定要执行的步骤顺序；甚至可以创建新的、可执行的工具（函数）来完成任务。

案例
> 你告诉 LLM：“写一篇关于黑洞的论文”
> LLM 自己决定：先“web search”查资料 → 并且能调用“news”和“arXiv”等工具，找最新科研动态
> 找到结果后，它自己判断：“我要选5个最好的来源” → 调用“web fetch” + “pdf to text”工具提取内容
> 然后它写初稿 → 再自己反思：“这个段落逻辑不够强，数据没引用清楚” → 主动改进草稿
> 最后输出高质量论文！

<img width="1776" height="608" alt="Image" src="https://github.com/user-attachments/assets/6f780d75-e191-4dbc-847d-27ed7512397a" />


### 四、benefits of agentic AI
1. 性能飞跃（Much Better Performance）
2. 并行加速（Faster than Humans because of Parallelization）
3. 模块化设计（Modular: Can Add/Update/Swap Components）

模块化设计的案例：

> 智能体工作流是高度模块化的，允许开发者自由地添加、更新工具或替换模型。
> 替换工具： 例如，在“网络搜索”这个环节，可以轻松地将默认的搜索引擎替换为 Serper、Bing、Dr. Google 或专门为 AI 设计的工具。
> 切换功能： 可以将通用的“web search”替换为“news search”，以便获取最新的科学突破资讯。
> 优化模型： 不必在所有步骤中使用同一个 LLM。可以根据不同步骤的需求，尝试不同的模型提供商，选择在该步骤表现最佳的模型，从而优化整个系统的表现。

agentic-ai一种让 AI Agent 根据明确或动态的任务目标，自主调用工具、访问数据库、执行步骤并完成任务的工作模式。
不同于传统“输入-输出”的简单问答，它强调多步骤规划、工具使用、状态更新与决策能力。

**代理型AI适合哪些任务？ (What tasks is agentic AI suited to?)**
这是一个从“容易”到“困难”的连续光谱

较易实现的任务 (Easier)

> 清晰、逐步的流程 (Clear, step-by-step process): 有明确的执行步骤。
> 标准程序 (Standard procedures to follow): 企业已有成熟的操作手册。
> 纯文本资产 (Text assets only): 输入和输出均为文本，因为LLM擅长处理文本。

较难实现的任务 (Harder)

> 步骤未知 (Steps not known ahead of time): 任务需求在执行前不确定，需要代理动态规划。
> 边执行边解决 (Plan/solve as you go): 代理需要在过程中进行推理和决策。
> 多模态输入 (Multimodal: sound, vision): 需要处理图像、声音等非文本

agentic-ai 是将人类工作流程自动化的新范式 —— 它不是取代人，而是把人从重复性、规则性强的任务中解放出来，专注于更高阶的决策与创造。


### 五、任务分解Task decomposition: Identifying the steps in a workflow

任务分解是构建代理型AI工作流的关键技能。其核心思想是：

> 观察人类行为: 思考如果一个人类要完成这个任务，他会怎么做？
> 拆解步骤: 将整个任务拆解成多个独立的、清晰的子步骤。
> 评估可行性: 对每个子步骤，思考它是否能用大型语言模型（LLM）或某个工具（如API、函数调用）来实现。
> 迭代优化: 如果初步分解的效果不理想，可以进一步细化某个步骤，将其拆分成更小的子步骤，直到达到满意的性能。



<img width="1200" height="700" alt="Image" src="https://github.com/user-attachments/assets/36bfbefe-d4fc-4bd4-9c38-323e73ec2f43" />

Idea: 通常我们会先想到一个初步的工作流程，对于拆解出的每个步骤，问自己：这一步能不能用LLM或者工具模块实现？（当然关键核对等也可以human in the loop）或者说整体完成的怎么样？不行我们就进一步拆分。

**工作流设计原则**
从简单开始：先做 1-3 步的原型，再逐步扩展。
模块化设计：每个步骤应尽量独立、可复用。
容错与反馈：加入“检查”、“评审”步骤，避免错误累积。
持续迭代：没有一步到位的完美工作流，需不断优化。

**关键技能**
任务分解能力: 能够清晰地识别和定义任务的各个离散步骤。
构件理解能力: 理解可用的模型和工具及其适用场景。
迭代优化能力: 不断测试、评估和改进工作流，直至达到预期性能。


### 六、Evaluation（evals）
能否进行严格、有纪律的评估（evals） 是区分一个团队或个人在构建智能体工作流时“做得好”与“做得差”的最大预测因素。评估能力对有效构建智能体工作流至关重要。
在构建智能体工作流前，很难预知所有可能出错的地方。
解决方案： 不要试图提前设计所有评估标准。最佳实践是先构建一个初步版本，然后手动检查其输出，寻找那些你希望它能做得更好的地方。

评估指标分为量化指标（objective metric）和相对主观的指标，前者可以由代码完成，后者可以由LLM打分(Using LLM as a judge)。

**评估的两大主要类型**
端到端评估 (End-to-end evals):衡量整个智能体最终输出的整体质量。 例如：评估一篇完整论文的最终得分。 2、组件级评估 (Component-level evals):衡量智能体工作流中单个步骤或组件的输出质量。 例如：评估第一步“提取关键信息”的准确性，或第二步“查找相关客户记录”的召回率。组件级评估是进行错误分析（error analysis）和优化工作流时的重要方法。


### 七、important agentic design pattern

**一、反思（reflection）**
核心概念： 让模型对自己的输出进行检查、评估和改进。
工作流程：
初始生成： 模型根据任务要求生成一个初步结果（如代码）。
自我评估/外部评估： 将该结果作为输入，再次提示同一个或另一个模型，要求其对结果进行批判性分析（如检查正确性、风格、效率，并给出改进建议）。
迭代优化： 将评估反馈（如“第5行有bug”或“单元测试失败”）提供给模型，让它基于反馈生成一个更好的版本。
循环往复： 此过程可以多次迭代，直到达到满意的质量。
关键点：
这是一种非常有效的性能提升技术，虽然不能保证100%完美，但能带来显著的性能提升。
“反思”可以由同一个模型完成，也可以引入一个专门扮演“审查者”角色的独立模型（即多智能体协作的雏形）。
评估标准可以是客观的（如代码是否能运行），也可以是主观的（如代码风格）。

**二、工具使用（Tool Use）**
核心概念： 赋予语言模型调用外部工具或函数的能力，以扩展其功能边界。

工作流程：
识别需求： 模型在处理任务时，判断需要调用哪个工具。
调用工具： 模型生成调用该工具的指令或参数。
执行与返回： 工具执行操作（如搜索网络、计算数学公式），并将结果返回给模型。
整合结果： 模型利用工具返回的结果来完成最终任务。
工具类型举例：
信息收集： Web search, Wikipedia, Database access.
分析计算： Code Execution, Wolfram Alpha, Bearly Code Interpreter.
生产力： Email, Calendar, Messaging.
图像处理： Image generation, Image captioning, OCR.
关键点： 工具使用极大地增强了模型的能力，使其不再局限于文本生成，而是能与现实世界互动并解决更广泛的问题。

**三、规划（Planning）**
核心概念： 让模型自主决定完成一个复杂任务所需的步骤序列，而不是由开发者硬编码。

工作流程：
任务理解： 模型接收一个复杂请求（如“生成一张女孩读书的图片，姿势与示例图中的男孩相同”）。
路径规划： 模型自动分解任务，决定需要调用哪些工具以及调用的顺序。
例如：先用 openpose 模型提取男孩的姿势 -> 再用 google/vit 模型根据该姿势生成女孩的图片 -> 接着用 vit-gpt2 模型描述图片 -> 最后用 fastspeech 模型将描述转为语音。
执行： 按照规划的步骤依次执行。
关键点：

这种方式比硬编码的流程更灵活，但控制难度更大，也更具实验性。
它允许模型在面对新任务时，自行构思解决方案，有时会产生令人惊喜的结果。

**四、多智能体协作（Multi-agent collaboration）**

核心概念： 雇佣多个具有不同专长的角色（智能体）协同工作，共同完成一个复杂项目。
工作流程：
角色分配： 为不同的智能体分配特定角色（如研究员、市场专员、编辑）。
分工合作： 各个智能体根据自己的角色和能力，执行相应的子任务。
沟通协调： 智能体之间相互沟通、传递信息，共同推进项目。

关键点：
多智能体协作通常能产生比单个智能体更好的结果，尤其在处理复杂任务（如撰写人物传记、下棋）时。
研究表明，多智能体系统在多项任务上的表现优于单智能体系统。
其缺点是更难控制和调试，因为无法提前预知各个智能体的行为。

_其实这个有点像人之间的讨论，不同的人看问题的视角和思维方式有很大不同，所以多人讨论工作就能一定程度上提升工作质量。_


