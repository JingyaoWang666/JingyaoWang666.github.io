### 1.指令系统概述复习
指令的设计是很有较大自由度，比如不同地址数目的指令。


### 2.操作类型
（1）数据传送指令
按照源-目的的顺序，分为寄存器-寄存器、寄存器-存储器（STORE）、存储器-寄存器（LOAD）、存储器-存储器。
堆栈操作：PUSH AX, POP AX
清零、置1：MOV AX, 0 ;  MOV AX, 1

（2）运算指令
算术运算：加、减、乘、除、求补、以及浮点数运算、十进制数运算。    如： ADD AX, 20
逻辑运算：与、或、非、异或。    如： AND AX, 30

（3）移位指令
包括：算术左移、算术右移、逻辑左移、逻辑右移、小循环左移、小循环右移、大循环左移、大循环右移

（4）转移指令
无条件转移：直接跳转到某处，不取决于任何条件。类似C语言里的goto语句。    如： JMP LOOP
条件转移： 根据机器当前的程序状态字中的某位来决定是否执行转移。    如：JZ LOOP
调用与返回指令：类比C语言中的函数调用与函数返回。    如： CALL PRO1 、 RET(return)
_子程序可以在多处被调用，子程序调用可以嵌套；CALL和RET要配对使用；要妥善保存子程序的返回地址_
陷阱（TRAP）指令：意外故障-陷阱信号-陷阱指令

（5）输入输出指令
对I/O单独编址的计算机，设置有专门的输入输出指令，用来操纵外设。    如： IN AX,[20] ;  OUT DX,AX

（6）其他指令
停机指令、空操作指令、开中断指令、关中断指令、置条件码指令；字符串传送、字符串比较、字符串查询、特权指令、向量指令、多处理机指令。


### 3.寻址方式
 **操作码 + 寻址特征 + 形式地址**
操作码表明指令功能，寻址特征表明寻址方式，形式地址指明操作数的位置（有效地址是操作数的真实地址。有效地址可以根据当前的寻址方式，由形式地址通过某种计算得到）

_下面的讲解约定：指令字长=存储字长=机器字长_

（1）立即寻址：指令中的形式地址部分不是操作数的地址，而是操作数本身。
特点：指令执行阶段不访存。指令中留给地址A的位数限制了立即数的范围。

（2）直接寻址：指令中的形式地址部分即为有效地址，即EA=A。
特点：执行阶段访问一次存储器。A的位数限制了该指令操作数的寻址范围。操作数的位置不易修改。

（3）隐含寻址：指令中不直接给出操作数地址，操作数地址隐含在操作码或某个（约定）寄存器中。

（4）间接寻址：指令中的形式地址不是操作数的地址，而是“操作数地址的地址”。可分为一次间址和多次间址。
一次间址：指令执行过程中需要两次访存；
多次间址：每次访问到的地址单元，看里面存的操作数的第一位是什么，代表就是真实地址还是还需要间接寻址。

优点：可以扩大寻址范围；便于编址转移程序（因为如果不用间接寻址，比如直接寻址，地址就在程序指令中写死了；而间接寻址可以改间接寻址的那个存储单元中的数据，从而实现程序的浮动）。

（5）寄存器(直接)寻址：指令中的形式地址直接指出寄存器的编号，操作数存储于寄存器中。    如： MOV AX,BX 指将编号为BX的寄存器中的操作数，移动到编号为AX的寄存器中。
特点：执行阶段不访存，只访问寄存器，执行速度快；可缩短指令字长（因为寄存器编号要求的位长可能比较短）。

（6）寄存器间接寻址：指令中的形式地址为寄存器的编号，寄存器的内容是操作数的有效地址。
特点：有效地址在寄存器中，操作数在存储器中，执行阶段访存便于编制循环程序。

（7）基址寻址：指令中的形式地址和基址寄存器的内容之和是有效地址。分为两种：一种是隐式基址寻址，采用专用寄存器作为基址寄存器（因此基址寄存器的地址相当于约定好了，不用显式地指出）；一种是显式基址寻址，采用通用寄存器作为基址寄存器（因为通用寄存器有多个，在指令中需要显式地指出使用哪一个通用寄存器作为基址寄存器）。显式基址寻址中，一般通用寄存器Ri中的内容不变，形式地址A可变（由操作系统或管理程序负责更改，用户没有权限更改）。

作用：扩大寻址范围；有利于多道程序（切换基址寄存器可以切换不同进程）；基址寄存器内容由操作系统或管理程序确定。

（8）变址寻址：有效地址为形式地址和变址寄存器IX的内容之和。
特点：扩大寻址范围；IX的内容由用户指定；便于处理数组问题（IX的内容作为数组首地址）。

（9）相对寻址：有效地址为程序计数器PC的值与形式地址之和。即有效地址EA = (PC) + A 。括号（X）表示X中的内容。

（10）堆栈寻址：遵守后进先出的原则。对应PUSH（将寄存器内容压入栈顶）/POP（将栈顶的内容弹出到某寄存器中）指令。堆栈寻址找到的单元总是栈顶的单元。














